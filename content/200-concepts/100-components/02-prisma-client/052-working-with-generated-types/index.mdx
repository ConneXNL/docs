---
title: 'Advanced usage of generated types'
metaTitle: 'Advanced usage of generated TypeScript types (Reference)'
metaDescription: 'Prisma Client provides full type safety for queries, even for partial queries or included relations. This page explains how to leverage the generated types.'
---

<TopBlock>

The generated code for Prisma Client contains several helpful types that you can use to make your application more type-safe. This page describes patterns for leveraging some of the generated types.

By importing the `Prisma` namespace from `@prisma/client` you can access types related to your defined schema models.

The following example composes a `select` param outside of the queries context using the [`validator`](#prisma-validator) function, it passes in a generated type (`UserSelect`) meaning only fields available on a `select` can be used.

```ts
// Import the Prisma namespace from the client package
import { PrismaClient, Prisma } from '@prisma/client'

const prisma = new PrismaClient()

// Pass in the UserSelect type assertion
const selectId = Prisma.validator<Prisma.UserSelect>()({
    id: true,
})

const data = await prisma.user.findFirst({ select: selectId })
```

> Note that you can find all type definitions inside the `index.d.ts` file inside the [generated `.prisma/client` folder](working-with-prismaclient/generating-prisma-client#the-prismaclient-npm-package).

</TopBlock>

All examples are based on the following schema:

<details><summary>Expand for sample schema</summary>

```prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Post {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  title     String   @db.VarChar(255)
  content   String?
  published Boolean  @default(false)
  author    User     @relation(fields: [authorId], references: [id])
  authorId  Int
}

model Profile {
  id     Int     @id @default(autoincrement())
  bio    String?
  user   User    @relation(fields: [userId], references: [id])
  userId Int     @unique
}

model User {
  id      Int      @id @default(autoincrement())
  email   String   @unique
  name    String?
  posts   Post[]
  profile Profile?
}
```

</details>

### <inlinecode>Prisma validator</inlinecode>

The `validator` is a function that exists on the Prisma namespace. It helps you create re-usable query parameters based on your schema models while making sure that the objects you create are valid.

You can also wrap a `validator` function and accept input, they can then be used when interacting with user created data, such as form inputs.

```ts
import { Prisma } from '@prisma/client'

const prisma = new PrismaClient()

// Create a new function that wraps the validator function and accepts input.
// Create a new user and a post from user input
const createUserAndPost =(name: string, email: string, postTitle: string, profileBio: string) => {
  return Prisma.validator<Prisma.UserCreateInput>()({
        name,
        email,
        posts: {
          create: {
            title: postTitle
          }
        },
        profile: {
          create: {
            bio: profileBio
          }
        }
    })
}

// Find a specific user from user input
const findSpecificUser = (name: string, email: string) => {
  return Prisma.validator<Prisma.UserWhereInput>()({
    name,
    email
  })
}

// Create the user in the database
await prisma.user.create({ data: createUserAndPost })

// Can be used to find a specific user based on form input
const oneUser = await prisma.user.findUnique({ where: findSpecificUser('Rich', 'rich@boop.com') })
```

The `createUserAndPost` custom function is created using the `validator` and passing a generated type (`UserCreateInput`) to the type assertion of the function. This generated type comes from your schema models.
The type assertion means that only fields that can be used when creating a user can be called inside the function.

All model query options are avaliable as types. The following will use the model `User` as an example of a model in your schema, except in the cases where a type exists on a model with relation fields,
then `Post` will be used.

### Generated types for `select`

The following examples demonstrate how to use the `validator` with [`select`](../../../../reference/api-reference/prisma-client-reference/#select) <span class="api"></span>:

  - `SelectAndInclude`
  - `UserSelect`

```ts
// SelectAndInclude
const selectNameIncludeEmail = Prisma.validator<Prisma.SelectAndInclude>()({
      select: {
        name: true
      },
      include: {
        email: true
      }
})

// UserSelect
const selectNameEmailNotPosts = Prisma.validator<Prisma.UserSelect>()({
      name: true,
      email: true,
      posts: false
})
```

### Generated types for `include`

The following examples demonstrate how to use the `validator` with [`include`](../../../../reference/api-reference/prisma-client-reference/#include) <span class="api"></span>:

  - `SelectAndInclude`
  - `UserInclude`

```ts
// SelectAndInclude
const selectNameIncludeEmail = Prisma.validator<Prisma.SelectAndInclude>()({
      select: {
        name: true
      },
      include: {
        email: true
      }
})

// UserInclude
const includePosts = Prisma.validator<Prisma.UserInclude>()({
      posts: true
})
```

### Generated types for `where`

The following examples demonstrate how to use the `validator` with [`where`](../../../../reference/api-reference/prisma-client-reference/#where) <span class="api"></span>:

  - `UserWhereInput`
```ts
// UserWhereInput
const whereNameIs = Prisma.validator<Prisma.UserWhereInput>()({
      name: 'Rich'
})

// It can be combined with conditional operators too
const whereNameIs = Prisma.validator<Prisma.UserWhereInput>()({
      name: 'Rich',
      AND: [
        {
          email: {
            contains: 'rich@boop.com'
          }
        }
      ]
})
```
  - `UserWhereUniqueInput` This type works by exposing any unique fields on the model. A field assigned `@id` is considered unique,
  as is one assigned `@unique`.
```ts
// UserWhereUniqueInput
const whereEmailIsUnique = Prisma.validator<Prisma.UserWhereUniqueInput>()({
      email: 'rich@boop.com'
})
```
  - `PostScalarWhereInput`
  ```ts
const whereScalarTitleIs = Prisma.validator<Prisma.PostScalarWhereInput>()({
        title: 'boop'
})
  ```
  - `PostUpdateWithWhereUniqueWithoutAuthorInput` - This type accepts a unique `where` field (an `@id` or another assigned `@unique`)
  and updates any field on the `Post` model except the `Author`. The `Author` is the scalar field on the `Post` model.
  ```ts
const updatePostByIdWithoutAuthor = Prisma.validator<Prisma.PostUpdateWithWhereUniqueWithoutAuthorInput>()({
      where: {
        id: 1
      },
      data: {
        content: 'This is some updated content',
        published: true,
        title: 'This is a new title'
      }
})
  ```
  - `PostUpsertWithWhereUniqueWithoutAuthorInput` - This type will update the `Post` records title field where the id matches, if it doesn't exist it will create it instead.
  ```ts
const updatePostTitleOrCreateIfNotExist = Prisma.validator<Prisma.PostUpsertWithWhereUniqueWithoutAuthorInput>()({
      where: {
        id: 1
      },
      update: {
        title: 'This is a new title'
      },
      create: {
        id: 1,
        title: 'If the title doesnt exist, then create one with this text'
      }
})
  ```
  - `PostUpdateManyWithWhereWithoutAuthorInput` - This type will update all `Post` records where published is set to false.
  ```ts
const publishAllPosts = Prisma.validator<Prisma.PostUpdateManyWithWhereWithoutAuthorInput>()({
      where: {
        published: {
          equals: false
        }
      },
      data: {
        published: true
      }
})
  ```
### Generated types for `orderBy`

The following examples demonstrate how to use the `validator` with [`orderBy`](../../../../reference/api-reference/prisma-client-reference/#orderBy) <span class="api"></span>:

- `UserOrderByInput`
  ```ts
const orderEmailsByDescending = Prisma.validator<Prisma.UserOrderByInput>()({
      email: 'desc'
})
  ```
